# ğŸ“š TÃ i Liá»‡u Giáº£ng Dáº¡y: KhoÃ¡ Há»c NestJS Microservices Thá»±c Chiáº¿n: Tá»« Zero Äáº¿n Hero

[![course thumbnail](https://res.cloudinary.com/djvmkh4cs/image/upload/v1754804493/Course_thumbnail_ej2mgk.png "course thumbnail")](https://res.cloudinary.com/djvmkh4cs/image/upload/v1754804493/Course_thumbnail_ej2mgk.png "course thumbnail")

## ğŸ¯ Giá»›i Thiá»‡u KhÃ³a Há»c

ChÃ o má»«ng cÃ¡c báº¡n Ä‘áº¿n vá»›i **"NestJS Microservices Thá»±c Chiáº¿n: Production-Ready E-Invoice System"** - má»™t khÃ³a há»c toÃ n diá»‡n vá» xÃ¢y dá»±ng há»‡ thá»‘ng microservices thá»±c táº¿ vá»›i **8 services**, **payment integration**, **centralized logging**, vÃ  **production deployment**.

### ğŸ“ Äá»‘i TÆ°á»£ng Há»c ViÃªn

| ğŸ‘¥ Äá»‘i TÆ°á»£ng | ğŸ“Š Level | ğŸ¯ Má»¥c TiÃªu | ğŸ’¼ á»¨ng Dá»¥ng |
|-------------|---------|------------|-------------|
| **Backend Developer** | Intermediate+ | NÃ¢ng cao ká»¹ nÄƒng Microservices | Senior Developer role |
| **Fullstack Developer** | Intermediate | Hiá»ƒu architecture phá»©c táº¡p | Solution Architect |
| **DevOps Engineer** | Beginner+ | Container orchestration | Production deployment |
| **Tech Lead** | Advanced | System design patterns | Team leadership |
| **Students/Graduates** | Intermediate | Real-world experience | Industry readiness |

### ğŸ† Learning Outcomes

#### ğŸ”§ Technical Skills
Sau khÃ³a há»c, báº¡n sáº½ **thÃ nh tháº¡o**:

```mermaid
mindmap
  root((Skills Mastered))
    Architecture
      Microservices Design
      API Gateway Pattern
      Event-Driven Architecture
      CQRS Implementation
    Development
      NestJS Advanced
      TypeScript Patterns
      Nx Monorepo
      Docker Containerization
    Integration
      Stripe Payments
      Kafka Events
      Redis Caching
      Keycloak Authentication
    Production
      Monitoring Setup
      Centralized Logging
      Error Handling
      Performance Optimization
```

#### ğŸ¯ Practical Achievements
- âœ… **Build 8 production-ready microservices** from scratch
- âœ… **Implement complete payment flow** with Stripe integration
- âœ… **Set up enterprise monitoring** with Grafana + Loki stack
- âœ… **Deploy scalable architecture** with Docker Compose
- âœ… **Handle real business logic** with invoice management
- âœ… **Master async communication** with Kafka events
- âœ… **Implement security patterns** with JWT + Redis caching

### ğŸ› ï¸ Prerequisites & Preparation

#### âœ… Required Knowledge
| Technology | Level | Verification |
|------------|-------|--------------|
| **JavaScript/TypeScript** | Intermediate | Can write classes, async/await, modules |
| **Node.js & npm** | Basic | Can install packages, run scripts |
| **REST APIs** | Basic | Understand HTTP methods, status codes |
| **Docker** | Basic | Can run containers, basic commands |
| **Git** | Basic | Clone, commit, push operations |

#### ğŸš€ Recommended Setup
```bash
# Environment Check
node --version          # v18+ required
npm --version           # v8+ required  
docker --version        # v20+ recommended
git --version           # v2.30+ recommended

# Recommended VS Code Extensions
code --install-extension ms-vscode.vscode-typescript-next
code --install-extension bradlc.vscode-tailwindcss
code --install-extension ms-vscode.vscode-json
code --install-extension bierner.markdown-mermaid
```

#### ğŸ’¡ Nice to Have
- MongoDB/NoSQL database experience
- Basic understanding of microservices concepts  
- Familiarity with payment systems
- Experience with monitoring tools
## ğŸ“Œ TÆ°Æ¡ng tÃ¡c vá»›i Giáº£ng viÃªn

KhÃ³a há»c khÃ´ng chá»‰ dá»«ng láº¡i á»Ÿ video lÃ½ thuyáº¿t â€“ báº¡n sáº½ luÃ´n cÃ³ **sá»± Ä‘á»“ng hÃ nh trá»±c tiáº¿p tá»« giáº£ng viÃªn** trong suá»‘t quÃ¡ trÃ¬nh há»c.

### ğŸ’¬ Há»i â€“ ÄÃ¡p nhanh chÃ³ng
- Äáº·t cÃ¢u há»i trá»±c tiáº¿p bÃªn dÆ°á»›i má»—i bÃ i há»c hoáº·c trong má»¥c Q&A.
- Nháº­n pháº£n há»“i nhanh chÃ³ng vÃ  giáº£i thÃ­ch rÃµ rÃ ng tá»« khÃ¡i niá»‡m cÆ¡ báº£n Ä‘áº¿n ká»¹ thuáº­t nÃ¢ng cao.

### ğŸ›  Há»— trá»£ xá»­ lÃ½ lá»—i
- MÃ´ táº£ váº¥n Ä‘á» vÃ  Ä‘Ã­nh kÃ¨m code khi gáº·p lá»—i.
- Giáº£ng viÃªn sáº½ hÆ°á»›ng dáº«n tá»«ng bÆ°á»›c Ä‘á»ƒ kháº¯c phá»¥c vÃ  giáº£i thÃ­ch nguyÃªn nhÃ¢n.

### ğŸ¤ Trao Ä‘á»•i cÃ¹ng cá»™ng Ä‘á»“ng há»c viÃªn
- Tham gia **group riÃªng** Ä‘á»ƒ tháº£o luáº­n, chia sáº» kinh nghiá»‡m vÃ  há»c há»i láº«n nhau.
- Káº¿t ná»‘i vá»›i cÃ¡c há»c viÃªn khÃ¡c Ä‘ang lÃ m trong ngÃ nh.
  
### ğŸŒ LiÃªn há»‡ & Káº¿t ná»‘i
Náº¿u báº¡n cáº§n há»— trá»£ hoáº·c muá»‘n káº¿t ná»‘i thÃªm ngoÃ i khÃ³a há»c, cÃ³ thá»ƒ liÃªn há»‡ qua:

- ğŸ“§ **Email:** [dotanthanhvlog@gmail.com](mailto:dotanthanhvlog@gmail.com)  
- ğŸ’¼ **LinkedIn:** [https://www.linkedin.com/in/thanh270600/](https://www.linkedin.com/in/thanh270600/)  
- ğŸ™ **GitHub:** [https://github.com/thanhmati](https://github.com/thanhmati)  
- ğŸ“º **YouTube:** [https://www.youtube.com/@laptrinhfullstack](https://www.youtube.com/@laptrinhfullstack)  
- ğŸ’¬ **Facebook Group:** [https://www.facebook.com/groups/ltfullstack](https://www.facebook.com/groups/ltfullstack)
- ğŸ“ **Zalo** 0762216048 

---

> ğŸ’¡ **PhÆ°Æ¡ng chÃ¢m:** *â€œHá»c tháº­t â€“ LÃ m tháº­tâ€*  
Giáº£ng viÃªn sáº½ luÃ´n theo sÃ¡t Ä‘á»ƒ báº¡n khÃ´ng chá»‰ **hoÃ n thÃ nh khÃ³a há»c**, mÃ  cÃ²n **tá»± tin triá»ƒn khai dá»± Ã¡n thá»±c táº¿**.

---

## ğŸ—ï¸ PHáº¦N 1: SYSTEM ARCHITECTURE DEEP DIVE

### 1.1 Architecture Overview

Há»‡ thá»‘ng E-Invoice Ä‘Æ°á»£c thiáº¿t káº¿ theo **Modern Microservices Architecture** vá»›i **Nx Monorepo**, triá»ƒn khai **14 components** bao gá»“m **8 microservices** vÃ  **6 infrastructure services**:

#### ğŸ¢ Application Layer (8 Microservices)
```mermaid
graph TB
    subgraph "ğŸŒ API Gateway Layer"
        BFF["ğŸšª BFF Service<br/>Port 3300<br/>â€¢ HTTP REST API<br/>â€¢ Swagger Documentation<br/>â€¢ Global Guards & Interceptors"]
    end
    
    subgraph "ğŸ’¼ Core Business Services"
        Invoice["ğŸ“„ Invoice Service<br/>â€¢ Business Logic<br/>â€¢ Payment Integration<br/>â€¢ Status Management<br/>â€¢ Kafka Producer"]
        UserAccess["ğŸ‘¤ User Access Service<br/>â€¢ User Management<br/>â€¢ Profile Operations<br/>â€¢ Data Validation"]
        Product["ğŸ›ï¸ Product Service<br/>â€¢ Product Catalog<br/>â€¢ Inventory Management<br/>â€¢ Pricing Logic"]
    end
    
    subgraph "ğŸ”§ Supporting Services"
        Media["ğŸ“ Media Service<br/>â€¢ File Upload<br/>â€¢ Cloudinary Integration<br/>â€¢ Image Processing"]
        PDF["ğŸ“„ PDF Generator<br/>â€¢ Template Rendering<br/>â€¢ Puppeteer Engine<br/>â€¢ EJS Templates"]
        Mail["ğŸ“§ Mail Service<br/>â€¢ Email Templates<br/>â€¢ SMTP Integration<br/>â€¢ Kafka Consumer"]
    end
    
    subgraph "ğŸ” Security & Auth"
        Auth["ğŸ” Authorizer Service<br/>â€¢ gRPC Authentication<br/>â€¢ JWT Validation<br/>â€¢ Keycloak Integration"]
    end
    
    BFF --> Invoice
    BFF --> UserAccess  
    BFF --> Product
    BFF --> Auth
    Invoice --> Media
    Invoice --> PDF
    Invoice --> Mail
    
    classDef gateway fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    classDef business fill:#f1f8e8,stroke:#388e3c,stroke-width:2px
    classDef support fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef security fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    
    class BFF gateway
    class Invoice,UserAccess,Product business
    class Media,PDF,Mail support
    class Auth security
```

#### ğŸ—ï¸ Infrastructure Layer (6 Services)
```
ğŸ“Š Production Infrastructure Stack
â”œâ”€â”€ ğŸ—„ï¸ MongoDB (Port 27017)
â”‚   â”œâ”€â”€ Document Database
â”‚   â”œâ”€â”€ Replica Set Ready
â”‚   â””â”€â”€ Mongoose ODM
â”œâ”€â”€ ğŸ“¨ Kafka (Port 9092, 29092)
â”‚   â”œâ”€â”€ Event Streaming Platform
â”‚   â”œâ”€â”€ Producer/Consumer Pattern
â”‚   â””â”€â”€ Auto Topic Creation
â”œâ”€â”€ ğŸ”‘ Keycloak (Port 8180)
â”‚   â”œâ”€â”€ Identity & Access Management
â”‚   â”œâ”€â”€ OAuth 2.0 / OpenID Connect
â”‚   â””â”€â”€ User Federation
â”œâ”€â”€ ğŸ”´ Redis (Port 6379)
â”‚   â”œâ”€â”€ Cache Store & Session Management
â”‚   â”œâ”€â”€ Token Caching (95% performance boost)
â”‚   â””â”€â”€ Redis Insight UI (Port 5540)
â”œâ”€â”€ ğŸ“Š Grafana (Port 3000)
â”‚   â”œâ”€â”€ Monitoring Dashboard
â”‚   â”œâ”€â”€ Log Visualization
â”‚   â””â”€â”€ Alerting System
â””â”€â”€ ğŸ“‹ Loki + Promtail (Port 3100)
    â”œâ”€â”€ Log Aggregation Server
    â”œâ”€â”€ LogQL Query Language
    â””â”€â”€ Docker Log Collection
```

### 1.2 SÆ¡ Äá»“ Tá»•ng Thá»ƒ Há»‡ Thá»‘ng

```mermaid
---
config:
  theme: mc
  look: neo
  layout: dagre
---
flowchart TB
    Client["ğŸŒ Client/Frontend"] --> BFF["ğŸšª BFF Service<br>:3000 (HTTP)"]
    BFF -- Guard Check --> UserGuard["ğŸ›¡ï¸ UserGuard<br>(Cache Layer)"]
    UserGuard -- gRPC: Authentication --> Auth["ğŸ” Authorizer<br>(gRPC Service)"]
    BFF -- TCP: CRUD Invoice --> Invoice["ğŸ“„ Invoice Service<br>(TCP Microservice)"]
    BFF -- TCP: User Management --> UserAccess["ğŸ‘¤ User Access<br>(TCP Microservice)"]
    BFF -- HTTP: Webhook --> Payment["ğŸ’³ Payment Service<br>(Stripe Integration)"]
    Invoice -- TCP: Generate PDF --> PDF["ğŸ“„ PDF Generator<br>(TCP Microservice)"]
    Invoice -- TCP: Upload File --> Media["ğŸ“ Media Service<br>(TCP Microservice)"]
    Invoice -- TCP: Payment Processing --> Payment
    Invoice -. "ğŸ“¨ Event: invoice.sent" .-> Kafka(("ğŸ”„ Kafka<br>:9092"))
    Kafka -. ğŸ“¨ Consume Events .-> Mail["ğŸ“§ Mail Service<br>(Kafka Consumer)"]
    Invoice -- Read/Write --> MongoDB[("ğŸ—„ï¸ MongoDB<br>:27017")]
    UserAccess -- Read/Write --> MongoDB
    UserGuard -- Token Cache --> Redis["ğŸ”´ Redis<br>:6379"]
    Media -- Upload Files --> Cloudinary["â˜ï¸ Cloudinary"]
    PDF -- HTML to PDF --> Puppeteer["ğŸ­ Puppeteer Engine"]
    Mail -- Send Email --> SMTP["ğŸ“® SMTP Server"]
    Auth -- User Management --> Keycloak["ğŸ”‘ Keycloak<br>:8180"]
    Payment -- Payment Processing --> Stripe["ğŸ’³ Stripe<br>(Payment Gateway)"]
    BFF -. Container Logs .-> Promtail["ğŸ“¡ Promtail<br>(Log Agent)"]
    Invoice -. Container Logs .-> Promtail
    UserAccess -. Container Logs .-> Promtail
    Mail -. Container Logs .-> Promtail
    Payment -. Container Logs .-> Promtail
    Promtail -- Ship Logs --> Loki["ğŸ“‹ Loki<br>:3100"]
    Loki -- Query Logs --> Grafana["ğŸ“Š Grafana<br>:3001"]
     Client:::externalBox
     BFF:::serviceBox
     UserGuard:::cacheBox
     Auth:::serviceBox
     Invoice:::serviceBox
     UserAccess:::serviceBox
     Payment:::serviceBox
     PDF:::serviceBox
     Media:::serviceBox
     Mail:::serviceBox
     Kafka:::eventBox
     MongoDB:::dbBox
     Redis:::cacheBox
     Cloudinary:::externalBox
     Puppeteer:::externalBox
     SMTP:::externalBox
     Keycloak:::externalBox
     Stripe:::externalBox
     Promtail:::serviceBox
     Loki:::serviceBox
     Grafana:::serviceBox
    classDef serviceBox fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef dbBox fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef externalBox fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef eventBox fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef cacheBox fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef paymentBox fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px

```

### 1.3 Chi Tiáº¿t Flow Dá»¯ Liá»‡u ChÃ­nh

```mermaid
sequenceDiagram
    participant C as ğŸŒ Client
    participant B as ğŸšª BFF
    participant I as ğŸ“„ Invoice Service
    participant P as ğŸ“„ PDF Generator
    participant M as ğŸ“ Media Service
    participant K as ğŸ”„ Kafka
    participant Mail as ğŸ“§ Mail Service
    participant DB as ğŸ—„ï¸ MongoDB
    participant Cloud as â˜ï¸ Cloudinary
    participant SMTP as ğŸ“® SMTP
    participant Pay as ğŸ’³ Payment Service
    participant Stripe as ğŸ’³ Stripe

    Note over C,Stripe: ğŸ”„ COMPLETE INVOICE & PAYMENT WORKFLOW

    %% 1. Create Invoice
    rect rgb(240, 248, 255)
        Note over C,DB: ğŸ“ Phase 1: Create Invoice
        C->>B: POST /api/v1/invoice
        B->>I: TCP: CREATE_INVOICE
        I->>DB: INSERT invoice (status: CREATED)
        DB-->>I: Invoice saved with ID
        I-->>B: Invoice ID
        B-->>C: âœ… Invoice created successfully
    end

    %% 2. Send Invoice (Complex Flow)
    rect rgb(255, 248, 240)
        Note over C,SMTP: ğŸ“¤ Phase 2: Send Invoice (Trigger PDF, Email & Payment)
        C->>B: POST /api/v1/invoice/:id/send
        B->>I: TCP: SEND_INVOICE
        
        %% PDF Generation
        Note over I,P: ğŸ¨ PDF Generation Sub-flow
        I->>P: TCP: CREATE_INVOICE_PDF
        P->>P: Render EJS template with invoice data
        P->>P: Convert HTML â†’ PDF (Puppeteer)
        P-->>I: PDF Base64 string
        
        %% File Upload
        Note over I,Cloud: â˜ï¸ File Upload Sub-flow
        I->>M: TCP: UPLOAD_FILE (PDF Base64)
        M->>Cloud: Upload PDF to Cloudinary
        Cloud-->>M: Public URL
        M-->>I: File URL
        
        %% Payment Session Creation
        Note over I,Stripe: ğŸ’³ Payment Session Sub-flow
        I->>Pay: TCP: CREATE_CHECKOUT_SESSION
        Pay->>Stripe: Create Checkout Session
        Stripe-->>Pay: Payment URL & Session ID
        Pay-->>I: Payment Link
        
        %% Update Database
        I->>DB: UPDATE invoice SET status='SENT', fileUrl='...', supervisorId
        DB-->>I: Invoice updated
        
        %% Kafka Event with Payment Link
        Note over I,Mail: ğŸ“¨ Async Event Processing
        I->>K: PUBLISH: invoice.sent event (with payment link)
        I-->>B: âœ… Invoice sent successfully
        B-->>C: âœ… Success response
    end

    %% 3. Email Processing with Payment Link (Async)
    rect rgb(248, 255, 248)
        Note over K,SMTP: ğŸ“§ Phase 3: Email Processing with Payment Link (Async)
        K->>Mail: CONSUME: invoice.sent event
        Mail->>I: TCP: GET_INVOICE_BY_ID
        I->>DB: SELECT invoice details
        DB-->>I: Invoice with fileUrl
        I-->>Mail: Complete invoice data with payment link
        
        Mail->>Mail: Render email template with payment link
        Mail->>Cloud: Download PDF from URL
        Cloud-->>Mail: PDF file
        Mail->>SMTP: Send email with PDF attachment + payment link
        SMTP-->>Mail: âœ… Email sent
    end

    %% 4. Payment Processing (Async)
    rect rgb(255, 240, 255)
        Note over C,Stripe: ğŸ’³ Phase 4: Payment Processing (Async)
        Note over C,Stripe: Customer clicks payment link in email
        C->>Stripe: Navigate to Checkout Session
        Stripe->>Stripe: Process payment
        Stripe->>B: POST /api/v1/payment/stripe/webhook
        B->>Pay: TCP: STRIPE_WEBHOOK
        Pay->>Pay: Verify webhook signature
        Pay->>Pay: Extract invoice ID from metadata
        Pay->>I: TCP: PAY_SUCCESS (invoice ID)
        I->>DB: UPDATE invoice SET status='PAID'
        DB-->>I: Invoice updated
        Pay-->>B: âœ… Webhook processed
        B-->>Stripe: âœ… 200 OK
    end
```

### 1.2 Service Communication Matrix

| ğŸ”„ Communication | Services | Protocol | Pattern | Performance | Use Case |
|------------------|----------|----------|---------|-------------|----------|
| **HTTP REST** | Frontend â†” BFF | HTTP/1.1 | Request/Response | Standard | External API |
| **TCP** | BFF â†” Business Services | TCP | RPC | High | Internal sync calls |
| **gRPC** | BFF â†” Authorizer | HTTP/2 | RPC | Very High | Authentication |
| **Kafka Events** | Invoice â†’ Mail | TCP | Pub/Sub | Scalable | Async processing |
| **Redis Cache** | UserGuard â†” Redis | TCP | Key/Value | Ultra Fast | Token caching |
| **HTTP Webhooks** | Stripe â†’ BFF | HTTP | Event-driven | Reliable | External events |
| **Database** | Services â†” MongoDB | TCP | Query/Command | Optimized | Data persistence |

### 1.3 Technology Stack & Justification

#### ğŸ—ï¸ Core Framework
```mermaid
graph LR
    subgraph Backend Framework
        NestJS["ğŸ  NestJS"]
        TypeScript["ğŸ“ TypeScript"]
        Nx["ğŸ“¦ Nx Monorepo"]
    end
    
    subgraph Communication Layer
        TCP["ğŸ”Œ TCP"]
        gRPC["âš¡ gRPC"]
        Kafka["ğŸ“¨ Kafka"]
    end
    
    subgraph Data Layer
        MongoDB["ğŸ—„ï¸ MongoDB"]
        Redis["ğŸ”´ Redis"]
    end
    
    classDef framework fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef communication fill:#f1f8e8,stroke:#388e3c,stroke-width:2px
    classDef data fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    
    class NestJS,TypeScript,Nx framework
    class TCP,gRPC,Kafka communication
    class MongoDB,Redis data
```

#### ğŸ› ï¸ Technology Decisions

| Technology | Why Chosen | Alternatives | Trade-offs |
|------------|------------|--------------|------------|
| **NestJS** | Enterprise framework, great for microservices | Express, Fastify | Learning curve vs features |
| **MongoDB** | Flexible schema, good for invoices | PostgreSQL, MySQL | Consistency vs flexibility |
| **Kafka** | High-throughput events | RabbitMQ, Redis Pub/Sub | Complexity vs scalability |
| **Docker** | Consistent environments | VM, bare metal | Resource overhead vs portability |
| **Keycloak** | Enterprise auth solution | Auth0, Firebase | Setup complexity vs features |
| **Stripe** | Best payment UX | PayPal, Square | Fees vs developer experience |

---

## ğŸ’³ PHáº¦N 2: STRIPE PAYMENT INTEGRATION DEEP DIVE

### 2.1 Complete Payment Architecture

Há»‡ thá»‘ng implement **end-to-end payment flow** vá»›i **Stripe Checkout Sessions**, **webhook handling**, vÃ  **automated status management**:

```mermaid
sequenceDiagram
    participant Customer as ğŸ‘¤ Customer
    participant Email as ğŸ“§ Email
    participant Stripe as ğŸ’³ Stripe
    participant BFF as ğŸšª BFF
    participant Invoice as ğŸ“„ Invoice Service
    participant DB as ğŸ—„ï¸ Database
    
    Note over Customer,DB: ğŸ’³ COMPLETE PAYMENT FLOW
    
    rect rgb(240, 248, 255)
        Note over Invoice,Email: 1. Invoice Creation & Email
        Invoice->>Stripe: Create Checkout Session
        Stripe-->>Invoice: Payment URL + Session ID
        Invoice->>Email: Send email with payment link
        Email->>Customer: ğŸ“§ Professional invoice email
    end
    
    rect rgb(255, 248, 240)
        Note over Customer,Stripe: 2. Customer Payment Process
        Customer->>Stripe: Click payment link
        Stripe->>Stripe: Process payment securely
        Customer->>Stripe: Complete payment
        Stripe->>Stripe: Payment successful
    end
    
    rect rgb(248, 255, 248)
        Note over Stripe,DB: 3. Webhook & Status Update
        Stripe->>BFF: POST /payment/stripe/webhook
        BFF->>BFF: Verify webhook signature
        BFF->>Invoice: Extract invoice ID from metadata
        Invoice->>DB: UPDATE status = 'PAID'
        BFF-->>Stripe: 200 OK (webhook confirmed)
    end
```

### 2.2 Payment Service Architecture

#### ğŸ—ï¸ Service Structure
```
apps/invoice/src/app/modules/payment/
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ payment.controller.ts       # TCP message handlers
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ payment.service.ts          # Business logic & webhook processing
â”‚   â””â”€â”€ stripe.service.ts           # Stripe API integration
â””â”€â”€ payment.module.ts               # Module configuration
```

#### ğŸ’¡ Key Implementation Details
```typescript
// Stripe Service - Checkout Session Creation
@Injectable()
export class StripeService {
  async createCheckoutSession(data: CreateCheckoutSessionRequest) {
    const session = await this.stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: data.lineItems.map(item => ({
        price_data: {
          currency: 'usd',
          product_data: { name: item.name },
          unit_amount: item.price * 100, // Convert to cents
        },
        quantity: item.quantity,
      })),
      mode: 'payment',
      customer_email: data.clientEmail,
      success_url: `${this.configService.get('STRIPE_CONFIG.SUCCESS_URL')}?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: this.configService.get('STRIPE_CONFIG.CANCEL_URL'),
      metadata: {
        invoiceId: data.invoiceId, // ğŸ”‘ Critical for webhook processing
      },
    });

    return {
      url: session.url,        // Payment link for email
      sessionId: session.id,   // For tracking
    };
  }
}
```

### 1.5.2 Payment Service Architecture

**ğŸ“ Vai trÃ²**: Xá»­ lÃ½ thanh toÃ¡n vÃ  webhook handling

```typescript
// apps/invoice/src/app/modules/payment/services/stripe.service.ts
@Injectable()
export class StripeService {
  private stripe: Stripe;

  constructor(private configService: ConfigService) {
    this.stripe = new Stripe(configService.get('STRIPE_CONFIG.SECRET_KEY'), {
      apiVersion: '2025-07-30.basil',
    });
  }

  async createCheckoutSession(data: CreateCheckoutSessionRequest) {
    const session = await this.stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: data.lineItems.map((item) => ({
        price_data: {
          currency: 'usd',
          product_data: {
            name: item.name,
          },
          unit_amount: item.price * 100,
        },
        quantity: item.quantity,
      })),
      mode: 'payment',
      customer_email: data.clientEmail,
      success_url: `${this.configService.get('STRIPE_CONFIG.SUCCESS_URL')}?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: this.configService.get('STRIPE_CONFIG.CANCEL_URL'),
      metadata: {
        invoiceId: data.invoiceId,
      },
    });

    return {
      url: session.url,
      sessionId: session.id,
    };
  }

  verifyWebhookSignature(body: Buffer, signature: string) {
    return this.stripe.webhooks.constructEvent(
      body, 
      signature, 
      this.configService.get('STRIPE_CONFIG.WEBHOOK_SECRET')
    );
  }
}
```

### 1.5.3 Webhook Processing

**ğŸ“ Vai trÃ²**: Xá»­ lÃ½ webhook tá»« Stripe Ä‘á»ƒ cáº­p nháº­t tráº¡ng thÃ¡i invoice

```typescript
// apps/invoice/src/app/modules/payment/services/payment.service.ts
@Injectable()
export class PaymentService {
  async stripeWebhook(data: StripeWebhookTcpReq) {
    const { rawBodyBase64, signature } = data;

    const event = this.stripeService.verifyWebhookSignature(
      Buffer.from(rawBodyBase64, 'base64'), 
      signature
    );

    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;

        if (session.metadata?.invoiceId) {
          await this.invoiceService.paySuccess(session.metadata.invoiceId);
        }
        break;
      }
      default:
        this.logger.log(`Unhandled event type ${event.type}`);
    }
  }
}
```

### 1.5.4 Email Template vá»›i Payment Link

**ğŸ“ Vai trÃ²**: Email template Ä‘á»™ng vá»›i payment link

```html
<!-- apps/mail/src/app/modules/mail-template/templates/invoice.ejs -->
<h2>Xin chÃ o <%= clientName %>,</h2>

<p>Báº¡n nháº­n Ä‘Æ°á»£c hÃ³a Ä‘Æ¡n tá»« <strong><%= senderName %></strong> vá»›i mÃ£ sá»‘ hÃ³a Ä‘Æ¡n <strong><%= invoiceCode %></strong>.</p>

<p>Vui lÃ²ng xem chi tiáº¿t hÃ³a Ä‘Æ¡n trong táº­p tin PDF Ä‘Ã­nh kÃ¨m.</p>

<% if (paymentLink) { %>
  <p>Äá»ƒ thuáº­n tiá»‡n cho viá»‡c thanh toÃ¡n, báº¡n cÃ³ thá»ƒ nháº¥n vÃ o liÃªn káº¿t bÃªn dÆ°á»›i Ä‘á»ƒ thanh toÃ¡n trá»±c tuyáº¿n:</p>

  <p>
    <a href="<%= paymentLink %>" target="_blank" style="color: #2196F3; font-weight: bold;">
      ğŸ‘‰ Thanh toÃ¡n ngay
    </a>
  </p>
<% } %>

<p>Náº¿u báº¡n cÃ³ báº¥t ká»³ cÃ¢u há»i nÃ o, xin vui lÃ²ng liÃªn há»‡ láº¡i vá»›i chÃºng tÃ´i.</p>
```

### 1.5.5 Payment Configuration

**ğŸ“ Vai trÃ²**: Cáº¥u hÃ¬nh Stripe cho development vÃ  production

```typescript
// libs/configuration/src/lib/stripe.config.ts
export class StripeConfiguration {
  @IsString()
  @IsNotEmpty()
  SECRET_KEY: string;

  @IsString()
  @IsNotEmpty()
  WEBHOOK_SECRET: string;

  @IsString()
  @IsNotEmpty()
  SUCCESS_URL: string;

  @IsString()
  @IsNotEmpty()
  CANCEL_URL: string;
}
```

**ğŸ”§ Environment Variables:**
```bash
# Stripe Configuration
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_SUCCESS_URL=http://localhost:3000/payment/success
STRIPE_CANCEL_URL=http://localhost:3000/payment/cancel
```

### 1.5.6 Security Features

**ğŸ›¡ï¸ Webhook Security:**
- **Signature Verification**: Verify webhook signature vá»›i Stripe secret
- **Event Validation**: Validate event type vÃ  data structure
- **Metadata Validation**: Ensure invoice ID exists trong metadata
- **Error Handling**: Graceful handling cá»§a invalid webhooks

**ğŸ” Payment Security:**
- **HTTPS Only**: Táº¥t cáº£ payment requests qua HTTPS
- **Token-based**: KhÃ´ng lÆ°u trá»¯ sensitive payment data
- **PCI Compliance**: Stripe handles PCI compliance
- **Fraud Protection**: Stripe's built-in fraud detection

---

## ğŸ“Š PHáº¦N 2: CENTRALIZED LOGGING ARCHITECTURE

### 2.1 Tá»•ng Quan Logging Stack

Há»‡ thá»‘ng sá»­ dá»¥ng **Grafana + Loki + Promtail** stack Ä‘á»ƒ thu tháº­p vÃ  quáº£n lÃ½ log táº­p trung:

```mermaid
graph TB
    %% Microservices Layer
    BFF["ğŸŒ BFF Service<br/>:3000"]
    Invoice["ğŸ“„ Invoice Service"]
    Mail["ğŸ“§ Mail Service"]
    UserAccess["ğŸ‘¤ User Access Service"]
    
    %% Docker Layer
    Docker["ğŸ³ Docker Engine<br/>/var/lib/docker/containers"]
    
    %% Logging Stack
    Promtail["ğŸ“¡ Promtail<br/>Log Collection Agent"]
    Loki["ğŸ“‹ Loki<br/>:3100<br/>Log Aggregation Server"]
    Grafana["ğŸ“Š Grafana<br/>:3001<br/>Dashboard & Visualization"]
    
    %% Log Flow
    BFF -->|"Container Logs"| Docker
    Invoice -->|"Container Logs"| Docker
    Mail -->|"Container Logs"| Docker
    UserAccess -->|"Container Logs"| Docker
    Payment -->|"Container Logs"| Docker
    
    Docker -->|"File System"| Promtail
    Promtail -->|"HTTP Push API"| Loki
    Loki -->|"LogQL Queries"| Grafana
    
    %% User Access
    User["ğŸ‘¨â€ğŸ’» Developer/DevOps"] -->|"Web UI"| Grafana
    User -->|"Direct API"| Loki
    
    %% Styling
    classDef serviceBox fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef logBox fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef userBox fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    
    class BFF,Invoice,Mail,UserAccess,Payment serviceBox
    class Docker,Promtail,Loki,Grafana logBox
    class User userBox
```

### 2.2 Promtail Configuration (Thá»±c Táº¿)

**ğŸ“ Vai trÃ²**: Thu tháº­p logs tá»« Docker containers vÃ  gá»­i Ä‘áº¿n Loki

```yaml
# docker/promtail-config.yaml
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: docker
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 5s

    pipeline_stages:
      - docker: {}

    relabel_configs:
      # GÃ¡n app label tá»« tÃªn container
      - source_labels: [__meta_docker_container_name]
        regex: /(.+)
        target_label: app
        replacement: $1

      # Lá»c chá»‰ invoice vÃ  bff containers
      - source_labels: [__meta_docker_container_name]
        regex: /invoice.*
        action: keep
      - source_labels: [__meta_docker_container_name]
        regex: /bff.*
        action: keep
```

**ğŸ’¡ Key Features:**
- **Docker Service Discovery**: Tá»± Ä‘á»™ng phÃ¡t hiá»‡n containers
- **Label Extraction**: GÃ¡n labels tá»« container metadata
- **Selective Collection**: Chá»‰ thu tháº­p logs tá»« invoice vÃ  bff services
- **Real-time Streaming**: Refresh interval 5 giÃ¢y

### 2.3 Loki Configuration (Thá»±c Táº¿)

**ğŸ“ Vai trÃ²**: Log aggregation server vá»›i efficient storage

```yaml
# docker/loki-config.yaml
auth_enabled: false

server:
  http_listen_port: 3100
  grpc_listen_port: 9096
  log_level: debug

common:
  instance_addr: 127.0.0.1
  path_prefix: /tmp/loki
  storage:
    filesystem:
      chunks_directory: /tmp/loki/chunks
      rules_directory: /tmp/loki/rules
  replication_factor: 1

schema_config:
  configs:
    - from: 2020-10-24
      store: tsdb
      object_store: filesystem
      schema: v13
      index:
        prefix: index_
        period: 24h

pattern_ingester:
  enabled: true
  metric_aggregation:
    loki_address: localhost:3100
```

**ğŸ’¡ Key Features:**
- **Filesystem Storage**: Local storage cho development
- **TSDB Schema**: Time-series database cho efficient querying
- **Pattern Ingester**: Tá»± Ä‘á»™ng extract patterns tá»« logs
- **No Authentication**: Simplified setup cho development

### 2.4 Grafana Integration

**ğŸ“ Vai trÃ²**: Dashboard vÃ  visualization cho logs

#### 2.4.1 Loki Data Source Setup
```json
{
  "name": "Loki",
  "type": "loki",
  "url": "http://loki:3100",
  "access": "proxy",
  "isDefault": true
}
```

#### 2.4.2 LogQL Query Examples
```logql
# Táº¥t cáº£ logs tá»« BFF service
{app="bff"}

# Error logs tá»« Invoice service
{app="invoice"} |= "ERROR"

# HTTP requests vá»›i response time > 1000ms
{app="bff"} | json | response_time > 1000

# Process ID tracking across services
{app=~"bff|invoice"} |= "process"

# Kafka event processing logs
{app="mail"} |= "invoice.sent"
```

### 2.5 Log Flow trong Microservices

```mermaid
sequenceDiagram
    participant App as ğŸ“± Application
    participant Docker as ğŸ³ Docker
    participant Promtail as ğŸ“¡ Promtail
    participant Loki as ğŸ“‹ Loki
    participant Grafana as ğŸ“Š Grafana
    participant Dev as ğŸ‘¨â€ğŸ’» Developer

    Note over App,Dev: ğŸ“‹ CENTRALIZED LOGGING FLOW

    %% Log Generation
    rect rgb(240, 248, 255)
        Note over App,Docker: 1. Log Generation
        App->>Docker: Write logs to stdout/stderr
        Docker->>Docker: Store logs in /var/lib/docker/containers
    end

    %% Log Collection
    rect rgb(255, 248, 240)
        Note over Docker,Loki: 2. Log Collection & Shipping
        Promtail->>Docker: Discover containers via Docker API
        Promtail->>Docker: Read log files
        Promtail->>Promtail: Apply labels vÃ  filtering
        Promtail->>Loki: HTTP Push API /loki/api/v1/push
        Loki->>Loki: Index vÃ  store logs
    end

    %% Log Visualization
    rect rgb(248, 255, 248)
        Note over Loki,Dev: 3. Log Query & Visualization
        Dev->>Grafana: Access dashboard http://localhost:3001
        Grafana->>Loki: LogQL queries
        Loki-->>Grafana: Log results
        Grafana-->>Dev: Dashboard vá»›i charts vÃ  logs
    end

    %% Real-time Monitoring
    rect rgb(255, 248, 255)
        Note over Grafana,Dev: 4. Real-time Monitoring
        Grafana->>Loki: Continuous queries (auto-refresh)
        Loki-->>Grafana: Live log stream
        Grafana-->>Dev: Real-time alerts vÃ  notifications
    end
```

### 2.6 Practical Benefits

#### 2.6.1 For Development
- **Centralized View**: Táº¥t cáº£ service logs á»Ÿ má»™t nÆ¡i
- **Real-time Monitoring**: Live log streaming
- **Process Tracking**: Follow request flow across services
- **Error Debugging**: Quick error identification vÃ  context

#### 2.6.2 For Production
- **Log Aggregation**: Thu tháº­p logs tá»« multiple instances
- **Search & Filter**: Powerful LogQL queries
- **Alerting**: Grafana alerts based on log patterns
- **Retention**: Configurable log retention policies

---

## ğŸ§© PHáº¦N 3: PHÃ‚N TÃCH Tá»ªNG MICROSERVICE

### 3.1 ğŸŒ BFF (Backend for Frontend) Service

**ğŸ“ Vai trÃ²**: API Gateway - Ä‘iá»ƒm táº­p trung cho frontend

#### 3.1.1 Cáº¥u TrÃºc Project
```
apps/bff/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts              # Entry point
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ app.module.ts    # Root module
â”‚   â”‚   â””â”€â”€ modules/
â”‚   â”‚       â”œâ”€â”€ invoice/     # Invoice endpoints
â”‚   â”‚       â”œâ”€â”€ product/     # Product endpoints  
â”‚   â”‚       â”œâ”€â”€ user/        # User endpoints
â”‚   â”‚       â””â”€â”€ authorizer/  # Auth endpoints
â”‚   â””â”€â”€ configuration/       # BFF-specific config
```

#### 3.1.2 Main.ts Configuration (Thá»±c táº¿)

```typescript
// apps/bff/src/main.ts
async function bootstrap() {
  try {
    const isDev = AppModule.CONFIGURATION.IS_DEV;
    const globalPrefix = AppModule.CONFIGURATION.GLOBAL_PREFIX;
    const port = AppModule.CONFIGURATION.APP_CONFIG.PORT || 3000;

    const app = await NestFactory.create<NestExpressApplication>(AppModule, {
      logger: isDev ? ['error', 'warn', 'log', 'debug', 'verbose'] : ['error', 'warn', 'log'],
    });

    // Global Configuration
    app.enableCors({ origin: '*' });
    app.useBodyParser('json', { limit: '20mb' });
    app.setGlobalPrefix(globalPrefix);
    app.useGlobalPipes(new ValidationPipe({ transform: true }));

    // Swagger Documentation
    const config = new DocumentBuilder()
      .setTitle('E-bff API')
      .setDescription('The E-bff API description')
      .setVersion('1.0.0')
      .addBearerAuth({
        description: 'Default JWT Authorization',
        type: 'http',
        in: 'header',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        name: 'Authorization',
      })
      .build();

    const documentFactory = () => SwaggerModule.createDocument(app, config);
    SwaggerModule.setup(`${globalPrefix}/docs`, app, documentFactory);

    await app.listen(port);
  } catch (error) {
    Logger.error(`âŒ Application failed to start: ${error}`);
  }
}
```

#### 3.1.3 App Module Structure (Thá»±c táº¿)

```typescript
// apps/bff/src/app/app.module.ts
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [() => ({ ...CONFIGURATION })],
    }),
    ClientsModule.registerAsync([GrpcProvider(GRPC_SERVICES.AUTHORIZER_SERVICE)]),
    ProductModule,
    InvoiceModule, 
    UserModule,
    AuthorizerModule,
  ],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: ExceptionInterceptor, // Global error handling
    },
    { provide: APP_GUARD, useClass: UserGuard }, // Global authentication guard
  ],
})
export class AppModule implements NestModule {
  static CONFIGURATION: TConfiguration = CONFIGURATION;

  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes('*'); // Global logging
  }
}
```

**ğŸ’¡ Key Features:**
1. **Global Guards**: UserGuard cho authentication
2. **Global Interceptors**: ExceptionInterceptor cho error handling
3. **Global Middleware**: LoggerMiddleware cho request logging
4. **gRPC Integration**: Authorizer service sá»­ dá»¥ng gRPC
5. **TCP Clients**: CÃ¡c service khÃ¡c sá»­ dá»¥ng TCP

---

### 3.2 ğŸ“„ Invoice Service (Core Business Logic)

**ğŸ“ Vai trÃ²**: Xá»­ lÃ½ logic nghiá»‡p vá»¥ chÃ­nh cá»§a hÃ³a Ä‘Æ¡n

#### 3.2.1 Service Structure (Thá»±c táº¿)
```
apps/invoice/src/app/modules/invoice/
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ invoice.controller.ts    # TCP Message handlers
â”œâ”€â”€ services/
â”‚   â””â”€â”€ invoice.service.ts       # Business logic
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ invoice.repository.ts    # Data access layer
â”œâ”€â”€ mappers/
â”‚   â””â”€â”€ index.ts                 # Data transformation
â””â”€â”€ invoice.module.ts            # Module configuration
```

#### 3.2.2 Invoice Module Configuration

```typescript
// apps/invoice/src/app/modules/invoice/invoice.module.ts
@Module({
  imports: [
    MongoProvider,
    MongooseModule.forFeature([InvoiceDestination]),
    ClientsModule.registerAsync([
      TcpProvider(TCP_SERVICES.PDF_GENERATOR_SERVICE),
      TcpProvider(TCP_SERVICES.MEDIA_SERVICE),
    ]),
  ],
  controllers: [InvoiceController],
  providers: [InvoiceService, InvoiceRepository],
})
export class InvoiceModule {}
```

#### 3.2.3 Business Logic Implementation (Thá»±c táº¿)

```typescript
// apps/invoice/src/app/modules/invoice/services/invoice.service.ts
@Injectable()
export class InvoiceService {
  constructor(
    private readonly invoiceRepository: InvoiceRepository,
    @Inject(TCP_SERVICES.PDF_GENERATOR_SERVICE) private readonly pdfGeneratorClient: TcpClient,
    @Inject(TCP_SERVICES.MEDIA_SERVICE) private readonly mediaClient: TcpClient,
    private readonly KafkaClient: KafkaClient,
  ) {}

  // 1. Create Invoice (status: CREATED)
  create(params: CreateInvoiceTcpReq) {
    const input = invoiceRequestMapping(params);
    return this.invoiceRepository.create(input);
  }

  // 2. Send Invoice (Complex business flow)
  async sendById(params: SendInvoiceTcpReq, processID: string) {
    const { invoiceId, userId } = params;
    const invoice = await this.getById(invoiceId);
    
    // Business rule validation
    if (invoice.status !== INVOICE_STATUS.CREATED) {
      throw new BadRequestException(ERROR_CODE.INVOICE_CAN_NOT_BE_SENT);
    }

    // Generate PDF via PDF Generator Service
    const pdfBase64 = await this.generatorInvoicePdf(
      { ...invoice.toObject(), status: INVOICE_STATUS.SENT }, 
      invoiceId
    );
    
    // Upload file via Media Service
    const pdfUrl = await this.uploadFile(
      { fileBase64: pdfBase64, fileName: `invoice-${invoiceId}` }, 
      processID
    );

    // Update invoice status and add supervisor
    const invoiceSent = await this.invoiceRepository.updateById(invoiceId, {
      status: INVOICE_STATUS.SENT,
      fileUrl: pdfUrl,
      supervisorId: new ObjectId(userId),
    });

    // Emit Kafka event for async processing
    this.KafkaClient.send<InvoiceSentPayload>(
      KAFKA_TOPICS.INVOICE.SENT, 
      { id: invoiceId }
    );

    return invoiceSent;
  }
}
```

#### 3.2.4 TCP Controller (Thá»±c táº¿)

```typescript
// apps/invoice/src/app/modules/invoice/controllers/invoice.controller.ts
@Controller()
export class InvoiceController {
  constructor(private readonly invoiceService: InvoiceService) {}

  @MessagePattern(TCP_REQUEST_MESSAGE.INVOICE.CREATE)
  create(params: TcpRequest<CreateInvoiceTcpReq>) {
    return this.invoiceService.create(params.data);
  }

  @MessagePattern(TCP_REQUEST_MESSAGE.INVOICE.SEND)
  send(params: TcpRequest<SendInvoiceTcpReq>) {
    return this.invoiceService.sendById(params.data, params.processID);
  }

  @MessagePattern(TCP_REQUEST_MESSAGE.INVOICE.GET_BY_ID)
  getById(params: TcpRequest<string>) {
    return this.invoiceService.getById(params.data);
  }

  // ... other CRUD operations
}
```

---

### 3.3 ğŸ“§ Mail Service (Event-Driven Consumer)

**ğŸ“ Vai trÃ²**: Xá»­ lÃ½ gá»­i email vÃ  consume Kafka events

#### 3.3.1 Kafka Consumer Setup (Thá»±c táº¿)

```typescript
// apps/mail/src/app/app.module.ts
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [() => ({ ...CONFIGURATION })],
    }),
    MailModule,
    MailTemplateModule,
    // Kafka Consumer configuration
    KafkaModule.forConsumerAsync({ 
      groupId: KAFKA_GROUPS.MAIL, 
      serviceName: KAFKA_SERVICES.MAIL 
    }),
  ],
})
export class AppModule {}
```

#### 3.3.2 Event Handler (Thá»±c táº¿)

```typescript
// apps/mail/src/app/modules/mail/services/mail-queue.service.ts
@Injectable()
export class MailQueueService {
  constructor(private readonly mailInvoiceService: MailInvoiceService) {}

  @KafkaHandler(KAFKA_TOPICS.INVOICE.SENT)
  async eventInvoiceCreated(payload: KafkaPayload<InvoiceSentPayload>) {
    const { message } = payload;
    await this.mailInvoiceService.sendInvoiceCreated(message);
  }
}
```

#### 3.3.3 Mail Business Logic (Thá»±c táº¿)

```typescript
// apps/mail/src/app/modules/mail/services/mail-invoice.service.ts
@Injectable()
export class MailInvoiceService {
  constructor(
    @Inject(TCP_SERVICES.INVOICE_SERVICE) private readonly invoiceClient: TcpClient,
    private readonly mailService: MailService,
    private readonly mailTemplateService: MailTemplateService,
  ) {}

  async sendInvoiceCreated(payload: InvoiceSentPayload) {
    const { id: invoiceId } = payload;

    // 1. Get invoice details from Invoice Service via TCP
    const invoice = await this.getInvoiceById(invoiceId);
    
    // 2. Render email template
    const html = await this.mailTemplateService.render('invoice', {
      clientName: invoice.client.name,
      senderName: 'Tan Thanh DEV',
      invoiceCode: `#${invoice.id}`,
    });

    // 3. Download PDF attachment from Cloudinary
    const attachment = await this.mailService.getAttachmentFromUrl(
      invoice.fileUrl,
      `invoice-${invoice.id}.pdf`,
      'application/pdf',
    );

    // 4. Send email with attachment
    this.mailService.sendMail({
      html,
      subject: 'Send Invoice',
      to: invoice.client.email,
      attachments: [attachment],
    });
  }

  private getInvoiceById(id: string) {
    return firstValueFrom(
      this.invoiceClient
        .send<GetDetailInvoiceTcpRes, string>(TCP_REQUEST_MESSAGE.INVOICE.GET_BY_ID, {
          data: id,
        })
        .pipe(map((data) => data.data)),
    );
  }
}
```

---

## ğŸ”§ PHáº¦N 4: SHARED LIBRARIES ANALYSIS

### 4.1 ğŸ“Š Database Schema Design (Thá»±c táº¿)

```typescript
// libs/schemas/src/lib/invoice/invoice.schema.ts
@Schema({
  timestamps: true,
  versionKey: false,
  collection: 'invoice',
  toJSON: { virtuals: true },
})
export class Invoice extends BaseSchema {
  @Prop({ type: Client })
  client: Client;

  @Prop({ type: Number })
  totalAmount: number;

  @Prop({ type: Number })
  vatAmount: number;

  @Prop({ 
    type: String, 
    enum: INVOICE_STATUS, 
    default: INVOICE_STATUS.CREATED 
  })
  status: INVOICE_STATUS;

  @Prop({ type: [Item] })
  items: Item[];

  @Prop({ type: ObjectId, ref: 'User', required: false })
  supervisorId?: ObjectId;

  @Prop({ type: String, required: false })
  fileUrl?: string;
}

// Invoice Status Enum (Thá»±c táº¿)
export enum INVOICE_STATUS {
  CREATED = 'created',
  SENT = 'sent',
  VERIFIED = 'verified',
  CANCELLED = 'cancelled', // TODO: Add this
}
```

### 4.2 ğŸ”„ Kafka Integration (Thá»±c táº¿)

#### 4.2.1 Kafka Topics

```typescript
// libs/constants/src/lib/kafka.constant.ts
export const KAFKA_TOPICS = {
  INVOICE: {
    SENT: 'invoice.sent', // Chá»‰ cÃ³ 1 topic hiá»‡n táº¡i
  },
};
```

#### 4.2.2 Kafka Consumer Service

```typescript
// libs/queue/src/lib/modules/kafka/services/kafka-consumer.service.ts
@Injectable()
export class KafkaConsumerService implements OnModuleInit, OnModuleDestroy {
  constructor(
    private readonly discoveryService: DiscoveryService,
    private readonly reflector: Reflector,
    @Inject(KAFKA_CONSUMER_OPTIONS) private readonly options: KafkaConsumerOptions,
  ) {
    this.kafka = new Kafka({
      clientId: this.options.serviceName + '-' + hostname(),
      brokers: this.options.url,
    });

    this.consumer = this.kafka.consumer({
      groupId: this.options.groupId,
      allowAutoTopicCreation: true,
    });
  }

  async onModuleInit() {
    await this.consumer.connect();

    // Auto-discover handlers with @KafkaHandler decorator
    const providers = this.discoveryService.getProviders()
      .filter((wrapper) => wrapper.instance && typeof wrapper.instance === 'object');

    for (const wrapper of providers) {
      const { instance } = wrapper;
      const prototype = Object.getPrototypeOf(instance);
      const methodNames = Object.getOwnPropertyNames(prototype)
        .filter((method) => typeof instance[method] === 'function' && method !== 'constructor');

      for (const methodName of methodNames) {
        const handler = instance[methodName];
        const metaData = this.reflector.get<KafkaHandlerMetadata>(KAFKA_HANDLER_METADATA, handler);

        if (metaData?.topic) {
          await this.consumer.subscribe({ topic: metaData.topic, fromBeginning: false });
          await this.consumer.run({
            eachMessage: async (context: EachMessagePayload) => {
              const { topic: msgTopic, message } = context;
              if (msgTopic !== metaData.topic) return;

              try {
                const value = message.value?.toString();
                const parsed = value ? JSON.parse(value) : null;
                const payload: KafkaPayload<any> = { context, message: parsed };
                await handler.call(instance, payload);
              } catch (error) {
                this.logger.error(`Error handling message for topic ${msgTopic}:`, error);
              }
            },
          });
        }
      }
    }
  }
}
```

### 4.3 ğŸ›¡ï¸ Error Handling & Logging (Thá»±c táº¿)

#### 4.3.1 Global Exception Interceptor

```typescript
// libs/interceptors/src/lib/exception.interceptor.ts
@Injectable()
export class ExceptionInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
    const request = context.switchToHttp().getRequest();
    const processUuid = request[MetadataKeys.PROCESS_ID];
    const startTime = request[MetadataKeys.START_TIME];

    return next.handle().pipe(
      map((data: ResponseDto<unknown>) => {
        const duration = Date.now() - startTime;
        data.processID = processUuid;
        data.duration = `${duration}ms`;
        return data;
      }),
      catchError((error) => {
        const duration = Date.now() - startTime;
        const code = error?.statusCode || HttpStatus.INTERNAL_SERVER_ERROR;
        const message = error?.message || HTTP_MESSAGE.INTERNAL_SERVER_ERROR;

        throw new HttpException(
          new ResponseDto({
            data: null,
            message,
            processID: processUuid,
            statusCode: code,
            duration: `${duration}ms`,
          }),
          code,
        );
      }),
    );
  }
}
```

#### 4.3.2 Logger Middleware

```typescript
// libs/middlewares/src/lib/logger.middleware.ts
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const processId = getProcessId();
    const startTime = Date.now();
    
    // Set metadata for tracking
    req[MetadataKeys.PROCESS_ID] = processId;
    req[MetadataKeys.START_TIME] = startTime;
    
    Logger.log(
      `HTTP Â» Start process '${processId}' Â» path: '${req.originalUrl}' Â» method: '${req.method}'`
    );

    // Override response Ä‘á»ƒ log completion
    const originalSend = res.send.bind(res);
    res.send = (body: any): Response => {
      const durationMs = Date.now() - startTime;
      Logger.log(
        `HTTP Â» End process '${processId}' Â» method: '${req.method}' Â» after: '${durationMs}ms'`
      );
      return originalSend(body);
    };

    next();
  }
}
```

---

## ğŸ”„ PHáº¦N 5: COMMUNICATION PATTERNS

### 5.1 Synchronous Communication (TCP)

```typescript
// BFF â†’ Invoice Service
this.invoiceClient.send<string, CreateInvoiceTcpReq>(
  TCP_REQUEST_MESSAGE.INVOICE.CREATE, 
  { data: body, processID }
)

// Invoice Service â†’ PDF Generator
this.pdfGeneratorClient.send<string, InvoiceTcpResponse>(
  TCP_REQUEST_MESSAGE.PDF_GENERATOR.CREATE_INVOICE_PDF,
  { data, processID }
)
```

### 5.2 gRPC Communication (Authorizer Service)

```typescript
// BFF â†’ Authorizer Service (gRPC)
ClientsModule.registerAsync([GrpcProvider(GRPC_SERVICES.AUTHORIZER_SERVICE)])
```

### 5.3 Asynchronous Communication (Kafka)

```typescript
// Producer (Invoice Service)
this.KafkaClient.send<InvoiceSentPayload>(
  KAFKA_TOPICS.INVOICE.SENT, 
  { id: invoiceId }
)

// Consumer (Mail Service)
@KafkaHandler(KAFKA_TOPICS.INVOICE.SENT)
async eventInvoiceCreated(payload: KafkaPayload<InvoiceSentPayload>) {
  await this.mailInvoiceService.sendInvoiceCreated(payload.message);
}
```

---

## ğŸ“ˆ PHáº¦N 6: BUSINESS FLOW ANALYSIS

### 6.1 Complete Invoice Workflow

```mermaid
sequenceDiagram
    participant F as Frontend
    participant B as BFF
    participant I as Invoice Service
    participant P as PDF Generator
    participant M as Media Service
    participant K as Kafka
    participant Mail as Mail Service
    participant DB as MongoDB
    participant C as Cloudinary

    Note over F,C: 1. CREATE INVOICE
    F->>B: POST /api/v1/invoice
    B->>I: TCP: CREATE_INVOICE
    I->>DB: Save invoice (status: CREATED)
    I-->>B: Invoice ID
    B-->>F: Success Response

    Note over F,C: 2. SEND INVOICE
    F->>B: POST /api/v1/invoice/:id/send
    B->>I: TCP: SEND_INVOICE
    
    Note over I,C: PDF Generation & Upload Flow
    I->>P: TCP: CREATE_INVOICE_PDF
    P->>P: Generate HTML from EJS template
    P->>P: Convert HTML to PDF with Puppeteer
    P-->>I: PDF Base64
    
    I->>M: TCP: UPLOAD_FILE
    M->>C: Upload PDF to Cloudinary
    C-->>M: Public URL
    M-->>I: File URL
    
    Note over I,Mail: Database Update & Event Flow
    I->>DB: Update status to SENT + fileUrl + supervisorId
    I->>K: Publish: invoice.sent event
    I-->>B: Success
    B-->>F: Success Response
    
    Note over K,Mail: Async Email Flow
    K->>Mail: Event: invoice.sent
    Mail->>I: TCP: GET_INVOICE_BY_ID
    Mail->>Mail: Render email template
    Mail->>C: Download PDF attachment
    Mail->>Mail: Send email via SMTP
```

### 6.2 Event-Driven Architecture

```mermaid
graph LR
    %% Event Producer
    InvoiceService[ğŸ“„ Invoice Service] -->|Publish| Topic[ğŸ“¨ invoice.sent]
    
    %% Kafka Broker
    Topic --> KafkaBroker((ğŸ”„ Kafka Broker))
    
    %% Event Consumer
    KafkaBroker --> MailConsumer[ğŸ“§ Mail Service<br/>Group: mail]
    
    %% Consumer Actions
    MailConsumer -->|Send Email| EmailAction[ğŸ“® Email with PDF Attachment]
    
    %% Styling
    classDef producer fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef topic fill:#f1f8e8,stroke:#388e3c,stroke-width:2px
    classDef consumer fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef action fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    
    class InvoiceService producer
    class Topic,KafkaBroker topic
    class MailConsumer consumer
    class EmailAction action
```

---

## ğŸ›ï¸ PHáº¦N 7: ARCHITECTURAL PATTERNS

### 7.1 Repository Pattern Implementation

```typescript
// apps/invoice/src/app/modules/invoice/repositories/invoice.repository.ts
@Injectable()
export class InvoiceRepository {
  constructor(
    @InjectModel(InvoiceModelName) private model: InvoiceModel
  ) {}

  create(input: CreateInvoiceInput) {
    return this.model.create(input);
  }

  async getById(id: string) {
    const invoice = await this.model.findById(id);
    if (!invoice) {
      throw new NotFoundException(ERROR_CODE.INVOICE_NOT_FOUND);
    }
    return invoice;
  }

  updateById(id: string, input: Partial<Invoice>) {
    return this.model.findByIdAndUpdate(id, input, { new: true });
  }

  paginate(params: PaginateInvoiceTcpReq) {
    return this.model.paginate({}, params);
  }
}
```

### 7.2 Dependency Injection Pattern

```typescript
// Constructor injection trong InvoiceService
constructor(
  private readonly invoiceRepository: InvoiceRepository,
  @Inject(TCP_SERVICES.PDF_GENERATOR_SERVICE) private readonly pdfGeneratorClient: TcpClient,
  @Inject(TCP_SERVICES.MEDIA_SERVICE) private readonly mediaClient: TcpClient,
  private readonly KafkaClient: KafkaClient,
) {}
```

### 7.3 API Gateway Pattern (BFF)

```typescript
// BFF acts as single entry point
Frontend â†’ BFF â†’ {
  Invoice Service (TCP),
  User Service (TCP),
  Authorizer Service (gRPC),
}
```

---

## ğŸ› ï¸ PHáº¦N 8: DEPLOYMENT & DOCKER

### 8.1 Docker Compose Structure

#### Infrastructure Services (docker-compose.provider.yaml)
```yaml
services:
  kafka:
    container_name: kafka
    image: bitnami/kafka:latest
    ports:
      - 9092:9092
    environment:
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092

  mongodb:
    image: mongo
    container_name: mongodb
    ports:
      - '27017:27017'
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: example

  keycloak:
    image: quay.io/keycloak/keycloak:25.0.0
    container_name: keycloak-25.0.0
    ports:
      - '8180:8080'
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
```

#### Application Services (docker-compose.dev.yaml)
```yaml
services:
  bff:
    container_name: bff
    image: bff:latest
    ports:
      - 3000:3000
    networks:
      - einvoice-nw

  invoice:
    container_name: invoice
    image: invoice:latest
    networks:
      - einvoice-nw

  # ... other services
```

### 8.2 Build & Deployment Commands

```bash
# Build all services
pnpm nx:run-many -t build

# Build Docker images
pnpm docker-build

# Start infrastructure
pnpm docker:start:provider

# Start application services
pnpm docker:start:dev

# Complete deployment
pnpm build
```

---

## ğŸ§ª PHáº¦N 9: BÃ€I Táº¬P THá»°C HÃ€NH

### BÃ i 1: ThÃªm Invoice Status Má»›i
**Má»¥c tiÃªu**: ThÃªm status `CANCELLED` cho invoice

**YÃªu cáº§u**:
1. Update `INVOICE_STATUS` enum
2. Implement `cancelById` method
3. Add business validation
4. Test vá»›i Swagger UI

**Code Template**:
```typescript
// libs/constants/src/lib/invoice.constant.ts
export enum INVOICE_STATUS {
  CREATED = 'created',
  SENT = 'sent',
  VERIFIED = 'verified',
  CANCELLED = 'cancelled', // TODO: Add this
}

// apps/invoice/src/app/modules/invoice/services/invoice.service.ts
async cancelById(id: string) {
  const invoice = await this.getById(id);
  
  // TODO: Add business validation
  if (invoice.status === INVOICE_STATUS.SENT) {
    throw new BadRequestException('Cannot cancel sent invoice');
  }
  
  return this.invoiceRepository.updateById(id, {
    status: INVOICE_STATUS.CANCELLED
  });
}
```

### BÃ i 2: Implement Notification Service
**Má»¥c tiÃªu**: Táº¡o service má»›i Ä‘á»ƒ handle notifications

**YÃªu cáº§u**:
1. Táº¡o Notification Service
2. Subscribe Kafka event `invoice.sent`
3. Gá»­i notification cho supervisor
4. LÆ°u notification history

### BÃ i 3: Add Request Validation
**Má»¥c tiÃªu**: Enhance DTO validation

**YÃªu cáº§u**:
1. Add custom validators
2. Implement business rule validation
3. Return detailed error messages
4. Test validation scenarios

### BÃ i 4: Implement Health Checks
**Má»¥c tiÃªu**: Add health monitoring

**YÃªu cáº§u**:
1. Add health check endpoints
2. Check database connectivity
3. Check Kafka connectivity
4. Return service status

### BÃ i 5: Centralized Logging Setup
**Má»¥c tiÃªu**: Enable vÃ  configure Grafana + Loki + Promtail

**YÃªu cáº§u**:
1. Uncomment logging services trong docker-compose.provider.yaml
2. Configure Grafana data source cho Loki
3. Táº¡o dashboard Ä‘á»ƒ monitor application logs
4. Setup log alerts cho error patterns

**Code Template**:
```bash
# Enable logging stack
docker-compose -f docker-compose.provider.yaml up -d grafana loki promtail

# Access Grafana
open http://localhost:3001  # admin/admin

# Add Loki data source
curl -X POST http://admin:admin@localhost:3001/api/datasources \
  -H "Content-Type: application/json" \
  -d '{"name":"Loki","type":"loki","url":"http://loki:3100","access":"proxy"}'
```

---

## ğŸš€ PHáº¦N 10: ADVANCED TOPICS

### 10.1 Authentication vá»›i Keycloak

```typescript
// User Guard Implementation
@Injectable()
export class UserGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    
    if (!token) {
      throw new UnauthorizedException();
    }
    
    // Verify JWT token with Keycloak
    return this.verifyKeycloakToken(token);
  }
}
```

### 10.2 Testing Strategies

```typescript
// Unit Test Example
describe('InvoiceService', () => {
  let service: InvoiceService;
  let repository: InvoiceRepository;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        InvoiceService,
        {
          provide: InvoiceRepository,
          useValue: {
            create: jest.fn(),
            getById: jest.fn(),
            updateById: jest.fn(),
          },
        },
        {
          provide: TCP_SERVICES.PDF_GENERATOR_SERVICE,
          useValue: { send: jest.fn() },
        },
      ],
    }).compile();

    service = module.get<InvoiceService>(InvoiceService);
    repository = module.get<InvoiceRepository>(InvoiceRepository);
  });

  it('should create invoice successfully', async () => {
    const mockInvoice = { id: '1', status: INVOICE_STATUS.CREATED };
    jest.spyOn(repository, 'create').mockResolvedValue(mockInvoice);

    const result = await service.create(createInvoiceDto);
    expect(result).toEqual(mockInvoice);
  });
});
```

### 10.3 Performance Optimization

```typescript
// Caching with Redis (Current Implementation)
@Injectable()
export class InvoiceService {
  @Cacheable('invoice', 300) // 5 minutes cache
  async getById(id: string) {
    return this.invoiceRepository.getById(id);
  }
}
```

---

## ğŸ”´ PHáº¦N 11: REDIS CACHE IMPLEMENTATION

### 11.1 Tá»•ng Quan Redis Cache

Há»‡ thá»‘ng Ä‘Ã£ implement **Redis Cache Layer** Ä‘á»ƒ tá»‘i Æ°u hÃ³a performance, Ä‘áº·c biá»‡t cho **authentication process**. Cache Ä‘Æ°á»£c sá»­ dá»¥ng chÃ­nh trong **UserGuard** Ä‘á»ƒ trÃ¡nh viá»‡c verify token vá»›i Keycloak liÃªn tá»¥c.

#### ğŸ¯ LÃ½ Do Implement Cache
```typescript
// Váº¥n Ä‘á»: Má»—i request Ä‘á»u pháº£i verify token vá»›i Keycloak
// âŒ Without Cache
BFF Request â†’ UserGuard â†’ Keycloak gRPC â†’ Verify Token â†’ Return UserData

// âœ… With Redis Cache  
BFF Request â†’ UserGuard â†’ Check Redis â†’ Return Cached UserData (if exists)
                      â†˜ Cache Miss â†’ Keycloak gRPC â†’ Cache Result â†’ Return UserData
```

### 11.2 Architecture & Configuration

#### ğŸ”§ Redis Configuration
```typescript
// libs/configuration/src/lib/redis.config.ts
export class RedisConfiguration {
  HOST: string;        // Default: 'redis'
  PORT: number;        // Default: 6379  
  TTL: number;         // Default: 30 * 60000 (30 minutes)
}

export const RedisProvider = CacheModule.registerAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  useFactory: async (configService: ConfigService) => ({
    stores: [
      createKeyv(`redis://${configService.get('REDIS_CONFIG.HOST')}:${configService.get('REDIS_CONFIG.PORT')}`),
    ],
    ttl: configService.get('REDIS_CONFIG.TTL'),
  }),
});
```

#### ğŸ—ï¸ Integration trong BFF
```typescript
// apps/bff/src/app/app.module.ts
@Module({
  imports: [
    RedisProvider,  // â† Redis Cache Module
    // ... other imports
  ],
  providers: [
    { provide: APP_GUARD, useClass: UserGuard }, // â† Guard sá»­ dá»¥ng cache
  ],
})
export class AppModule {}
```

### 11.3 UserGuard Cache Implementation

#### ğŸ›¡ï¸ Cache Strategy trong UserGuard
```typescript
// libs/guard/src/lib/user.guard.ts
@Injectable()
export class UserGuard implements CanActivate {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    // ... other dependencies
  ) {}

  // 1. Generate secure cache key
  generateTokenCacheKey(token: string): string {
    const hash = crypto.createHash('sha256').update(token).digest('hex');
    return `user-token:${hash}`;
  }

  // 2. Cache-first verification strategy
  private verifyUserToken(req: any): Observable<boolean> {
    const token = getAccessToken(req);
    const cacheKey = this.generateTokenCacheKey(token);

    return new Observable<boolean>((observer) => {
      // Check cache first
      this.cacheManager.get<AuthorizedResult>(cacheKey).then((cached) => {
        if (cached) {
          // âœ… Cache HIT - Use cached data
          setUserData(req, cached);
          observer.next(true);
          observer.complete();
        } else {
          // âŒ Cache MISS - Verify with Keycloak
          this.keycloakService
            .verifyUserToken({ token, processID })
            .pipe(
              map(({ data, error }) => {
                if (!data?.valid) {
                  throw new UnauthorizedException(error);
                }

                setUserData(req, data);
                
                // Cache the result for 30 minutes
                this.cacheManager.set(cacheKey, data, 30 * 60 * 1000);

                observer.next(true);
                observer.complete();
              })
            )
            .subscribe();
        }
      });
    });
  }
}
```

### 11.4 Cache Flow Diagram

```mermaid
sequenceDiagram
    participant Client
    participant BFF
    participant UserGuard  
    participant Redis
    participant Keycloak

    Client->>BFF: HTTP Request with Token
    BFF->>UserGuard: canActivate()
    UserGuard->>UserGuard: generateTokenCacheKey(token)
    
    alt Cache HIT
        UserGuard->>Redis: get(cacheKey)
        Redis-->>UserGuard: cached userData
        UserGuard->>BFF: setUserData() & return true
        BFF-->>Client: Response with cached data
    else Cache MISS
        UserGuard->>Redis: get(cacheKey)
        Redis-->>UserGuard: null
        UserGuard->>Keycloak: verifyUserToken(gRPC)
        Keycloak-->>UserGuard: userData
        UserGuard->>Redis: set(cacheKey, userData, 30min)
        UserGuard->>BFF: setUserData() & return true
        BFF-->>Client: Response with fresh data
    end
```

### 11.5 Security Considerations

#### ğŸ” Token Security
```typescript
// âœ… Security Best Practices
1. **Hash Token**: SHA256 hash thay vÃ¬ lÆ°u raw token
   - TrÃ¡nh token leakage trong Redis logs
   - Key collision cá»±c ká»³ tháº¥p

2. **TTL Management**: Auto-expire sau 30 phÃºt
   - TrÃ¡nh stale data
   - Sync vá»›i Keycloak token expiry

3. **Namespace Keys**: Prefix `user-token:` 
   - TrÃ¡nh key collision vá»›i cache khÃ¡c
   - Dá»… dÃ ng monitor vÃ  debug
```

#### ğŸ¯ Cache Key Strategy
```typescript
// Cache Key Format: user-token:{sha256_hash}
const token = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...";
const hash = crypto.createHash('sha256').update(token).digest('hex');
const cacheKey = `user-token:${hash}`;
// Result: "user-token:a1b2c3d4e5f6..."
```

### 11.6 Performance Metrics

#### ğŸ“Š Expected Performance Gains
```typescript
// Without Cache (má»—i request)
- Keycloak gRPC call: ~50-100ms
- Network latency: ~10-20ms  
- Total per request: ~60-120ms

// With Cache (cache hit)
- Redis get operation: ~1-5ms
- Performance gain: 90-95% faster
- Reduced load on Keycloak: Significant
```

### 11.7 Monitoring & Debugging

#### ğŸ” Debug Commands
```bash
# Connect to Redis container
docker exec -it redis_server redis-cli

# List all cache keys
KEYS user-token:*

# Get cache value
GET user-token:a1b2c3d4e5f6...

# Check TTL
TTL user-token:a1b2c3d4e5f6...

# Monitor cache operations
MONITOR
```

#### ğŸ“ˆ Metrics to Track
- Cache hit ratio
- Average response time  
- Keycloak request reduction
- Memory usage

### 11.8 Thá»±c HÃ nh: Testing Cache

#### ğŸ§ª Test Cache Behavior
```bash
# 1. First request (cache miss)
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://localhost:3000/api/v1/invoice

# 2. Second request (cache hit - should be faster)  
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://localhost:3000/api/v1/invoice

# 3. Check Redis
docker exec -it redis_server redis-cli
> KEYS user-token:*
> GET user-token:{hash}
```

---

## ğŸ“š PHáº¦N 12: TÃ€I LIá»†U THAM KHáº¢O

### 11.1 Official Documentation
- [NestJS Documentation](https://docs.nestjs.com/)
- [MongoDB Manual](https://docs.mongodb.com/manual/)
- [Kafka Documentation](https://kafka.apache.org/documentation/)
- [Keycloak Documentation](https://www.keycloak.org/documentation)
- [Docker Documentation](https://docs.docker.com/)

### 11.2 Design Patterns
- [Microservices Patterns](https://microservices.io/patterns/)
- [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/)

### 11.3 Best Practices
- [12-Factor App](https://12factor.net/)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

---

## ğŸ“ Káº¾T LUáº¬N

Há»‡ thá»‘ng E-Invoice nÃ y lÃ  má»™t vÃ­ dá»¥ tuyá»‡t vá»i vá» **Production-Ready Microservices Architecture**. CÃ¡c Ä‘iá»ƒm ná»•i báº­t:

### âœ… Strengths
1. **Well-structured**: Clear separation of concerns vá»›i Nx monorepo
2. **Scalable**: Each service can scale independently
3. **Maintainable**: Clean code vá»›i proper abstractions
4. **Observable**: Comprehensive logging vÃ  error handling
5. **Testable**: Dependency injection cho easy mocking
6. **Production-ready**: Docker containerization vÃ  proper configuration

### ğŸ”„ Architecture Highlights
- **7 Microservices** vá»›i vai trÃ² rÃµ rÃ ng
- **Mixed Communication**: TCP (sync), gRPC (auth), Kafka (async)
- **Event-Driven**: Kafka cho decoupled communication
- **Authentication**: Keycloak integration vá»›i Redis cache layer
- **File Processing**: PDF generation vÃ  cloud storage
- **Performance Optimization**: Redis caching cho authentication tokens

### ğŸ¯ Key Takeaways
- **Microservices** cáº§n cÃ¢n nháº¯c trade-offs giá»¯a complexity vÃ  benefits
- **Event-Driven Architecture** giÃºp decouple services nhÆ°ng tÄƒng complexity
- **Proper error handling** vÃ  **logging** ráº¥t quan trá»ng trong distributed systems
- **Configuration management** cáº§n Ä‘Æ°á»£c centralized vÃ  environment-specific
- **Testing strategy** cáº§n cover unit, integration vÃ  e2e tests

---

**Happy Learning! ğŸš€**

*TÃ i liá»‡u nÃ y Ä‘Æ°á»£c cáº­p nháº­t Ä‘á»ƒ pháº£n Ã¡nh chÃ­nh xÃ¡c source code hiá»‡n táº¡i. Má»i gÃ³p Ã½ xin liÃªn há»‡ Ä‘á»ƒ cáº£i thiá»‡n cháº¥t lÆ°á»£ng ná»™i dung.*
